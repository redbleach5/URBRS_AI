{"value": "512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==\",\n      \"dev\": true,\n      \"license\": \"ISC\"\n    },\n    \"node_modules/imurmurhash\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz\",\n      \"integrity\": \"sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==\",\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"engines\": {\n        \"node\": \">=0.8.19\"\n      }\n    },\n    \"node_modules/indent-string\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz\",\n      \"integrity\": \"sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==\",\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/infer-owner\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/infer-owner/-/infer-owner-1.0.4.tgz\",\n      \"integrity\": \"sha512-IClj+Xz94+d7irH5qRyfJonOdfTzuDaifE6ZPWfx0N0+/ATZCbuTPq2prFl526urkQd90WyUKIh1DfBQ2hMz9A==\",\n      \"license\": \"ISC\",\n      \"optional\": true\n    },\n    \"node_modules/inflight\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n      \"integrity\": \"sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==\",\n      \"deprecated\": \"This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.\",\n      \"license\": \"ISC\",\n      \"optional\": true,\n      \"dependencies\": {\n        \"once\": \"^1.3.0\",\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/inherits\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMC\n\n#!/usr/bin/env node\n\n/**\n * \u0421\u043a\u0440\u0438\u043f\u0442 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f IP \u0430\u0434\u0440\u0435\u0441\u0430 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u0430 \u0432 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0435\u0442\u0438\n * \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043d\u0430 \u0432\u0441\u0435\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430\u0445 (macOS, Linux, Windows)\n */\n\nconst os = require('os');\nconst { execSync } = require('child_process');\n\nconsole.log('\ud83d\udd0d \u041f\u043e\u0438\u0441\u043a IP \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u0438\u0437 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0435\u0442\u0438...\\n');\n\nfunction getIPAddresses() {\n  const interfaces = os.networkInterfaces();\n  const addresses = [];\n\n  for (const name of Object.keys(interfaces)) {\n    for (const iface of interfaces[name]) {\n      // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0435 \u0438 \u043d\u0435\u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u0430\u0434\u0440\u0435\u0441\u0430\n      if (iface.family === 'IPv4' && !iface.internal) {\n        // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c loopback \u0438 link-local \u0430\u0434\u0440\u0435\u0441\u0430\n        if (!iface.address.startsWith('127.') && !iface.address.startsWith('169.254.')) {\n          addresses.push({\n            address: iface.address,\n            interface: name\n          });\n        }\n      }\n    }\n  }\n\n  return addresses;\n}\n\nconst addresses = getIPAddresses();\n\nif (addresses.length > 0) {\n  console.log('\ud83d\udcf1 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0430\u0434\u0440\u0435\u0441\u0430:');\n  addresses.forEach(({ address, interface: iface }) => {\n    console.log(`   http://${address}:3000`);\n    console.log(`      (\u0418\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441: ${iface})`);\n  });\n  console.log('');\n  console.log('\ud83d\udca1 \u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u044d\u0442\u0438\u0445 \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u043d\u0430 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u043c \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0435');\n  console.log('   \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430 \u0432 \u043e\u0434\u043d\u043e\u0439 Wi-Fi \u0441\u0435\u0442\u0438!');\n} else {\n  console.log('\u274c \u041d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0445 \u0441\u0435\u0442\u0435\u0432\u044b\u0445 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u043e\u0432');\n}\n\n\n\n#!/usr/bin/env node\n\n/**\n * \u0421\u043a\u0440\u0438\u043f\u0442 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f IP \u0430\u0434\u0440\u0435\u0441\u0430 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u0430 \u0432 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0435\u0442\u0438\n * \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043d\u0430 \u0432\u0441\u0435\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430\u0445 (macOS, Linux, Windows)\n */\n\nconst os = require('os');\nconst { execSync } = require('child_process');\n\nconsole.log('\ud83d\udd0d \u041f\u043e\u0438\u0441\u043a IP \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u0438\u0437 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0435\u0442\u0438...\\n');\n\nfunction getIPAddresses() {\n  const interfaces = os.networkInterfaces();\n  const addresses = [];\n\n  for (const name of Object.keys(interfaces)) {\n    for (const iface of interfaces[name]) {\n      // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0435 \u0438 \u043d\u0435\u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u0430\u0434\u0440\u0435\u0441\u0430\n      if (iface.family === 'IPv4' && !iface.internal) {\n        // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c loopback \u0438 link-local \u0430\u0434\u0440\u0435\u0441\u0430\n        if (!iface.address.startsWith('127.') && !iface.address.startsWith('169.254.')) {\n          addresses.push({\n            address: iface.address,\n            interface: name\n          });\n        }\n      }\n    }\n  }\n\n  return addresses;\n}\n\nconst addresses = getIPAddresses();\n\nif (addresses.length > 0) {\n  console.log('\ud83d\udcf1 \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0430\u0434\u0440\u0435\u0441\u0430:');\n  addresses.forEach(({ address, interface: iface }) => {\n    console.log(`   http://${address}:3000`);\n    console.log(`      (\u0418\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441: ${iface})`);\n  });\n  console.log('');\n  console.log('\ud83d\udca1 \u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u044d\u0442\u0438\u0445 \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u043d\u0430 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u043c \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0435');\n  console.log('   \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430 \u0432 \u043e\u0434\u043d\u043e\u0439 Wi-Fi \u0441\u0435\u0442\u0438!');\n} else {\n  console.log('\u274c \u041d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0445 \u0441\u0435\u0442\u0435\u0432\u044b\u0445 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u043e\u0432');\n}\n\n\n\nimport express from 'express';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\nimport rateLimit from 'express-rate-limit';\nimport { dbGet, dbRun } from '../database';\nimport { authenticate, AuthRequest } from '../middleware/auth';\nimport { logger, loggerManager } from '../utils/logger';\nimport { User, UserPublic } from '../types/database';\nimport { asyncHandler } from '../middleware/errorHandler';\nimport type { AuthResponse, User as SharedUser } from '../../shared/types';\n\n// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 JWT_SECRET \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435 \u043c\u043e\u0434\u0443\u043b\u044f\nif (!process.env.JWT_SECRET && process.env.NODE_ENV === 'production') {\n  throw new Error('JWT_SECRET must be set in production environment');\n}\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'secret';\n\n// Rate limiting \u0434\u043b\u044f auth endpoints\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 \u043c\u0438\u043d\u0443\u0442\n  max: 5, // 5 \u043f\u043e\u043f\u044b\u0442\u043e\u043a\n  message: '\u0421\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u043d\u043e\u0433\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a \u0432\u0445\u043e\u0434\u0430. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u043f\u043e\u0437\u0436\u0435.',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst registerLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 \u0447\u0430\u0441\n  max: 3, // 3 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438\n  message: '\u0421\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u043d\u043e\u0433\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u043f\u043e\u0437\u0436\u0435.',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst resetPasswordLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 \u0447\u0430\u0441\n  max: 3, // 3 \u043f\u043e\u043f\u044b\u0442\u043a\u0438\n  message: '\u0421\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u043d\u0430 \u0441\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u043e\u043b\u044f. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u043f\u043e\u0437\u0436\u0435.',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst router = express.Router();\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u0438 email\nfunction isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u0438 \u043f\u0430\u0440\u043e\u043b\u044f\nfunction isValidPassword(password: string): { valid: boolean; error?: string } {\n  if (password.length < 8) {\n    return { valid: false, error: '\u041f\u0430\u0440\u043e\u043b\u044c \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043d\u0435 \u043c\u0435\u043d\u0435\u0435 8 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432' };\n  }\n  if (password.length > 128) {\n    return { valid: false, error: '\u041f\u0430\u0440\u043e\u043b\u044c \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0442\u044c 128 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432' };\n  }", "timestamp": 1767393598.3040278, "ttl": 3600}